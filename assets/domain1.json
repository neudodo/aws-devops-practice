{
  "id": "domain1",
  "name": "SDLC Automation",
  "icon": "üöÄ",
  "percentage": 22,
  "color": "blue",
  "questions": [
    {
      "id": 1,
      "question": "A CodeBuild project needs to access resources in a private VPC. What must be configured? (Choose 2)",
      "options": [
        "VPC configuration in CodeBuild project settings",
        "NAT Gateway for internet access",
        "Security groups allowing CodeBuild access",
        "VPC peering with CodeBuild VPC",
        "Internet Gateway in the VPC"
      ],
      "correctIndexes": [0, 2],
      "explanation": {
        "hu": "CodeBuild VPC config: 1) VPC Configuration (VPC, subnets, SGs), 2) Security Groups allow access to private resources. NAT Gateway csak ha internet access kell.",
        "whyCorrect": "VPC config and security groups are required for private resource access",
        "whyWrong": [
          null,
          "NAT Gateway optional, csak internet access-hez kell",
          null,
          "VPC peering nem sz√ºks√©ges, CodeBuild uses ENI",
          "Internet Gateway nem sz√ºks√©ges private resource access-hez"
        ]
      },
      "examTip": "CodeBuild VPC ‚Üí VPC config + Security Groups",
      "difficulty": "Medium",
      "multipleAnswers": true
    },
    {
      "id": 20,
      "question": "A company needs to implement a CI/CD pipeline that deploys to production only after manual approval. The pipeline should automatically build and test in the development environment. Which AWS services combination best meets this requirement?",
      "options": [
        "CodeCommit, CodeBuild, CodeDeploy with Lambda approval function",
        "CodePipeline with CodeBuild, manual approval action, and CodeDeploy",
        "Jenkins with AWS Lambda for approval and CodeDeploy",
        "CodePipeline with EventBridge approval and CloudFormation"
      ],
      "correctIndex": 1,
      "explanation": {
        "hu": "CodePipeline nat√≠v t√°mogatja a manual approval action-t. CodeBuild build-el √©s testel, Manual Approval action pauseolja a pipeline-t approval-ra v√°rva, CodeDeploy deploy-ol production-be. Ez a legegyszer≈±bb AWS-native megold√°s.",
        "whyCorrect": "Native AWS feature, egyszer≈± konfigur√°ci√≥, built-in manual approval, minim√°lis operational overhead",
        "whyWrong": [
          "Lambda approval function feleslegesen komplex custom megold√°s",
          null,
          "Jenkins nem nat√≠v AWS megold√°s, t√∂bb maintenance overhead",
          "EventBridge nem t√°mogat manual approval-t directly"
        ]
      },
      "examTip": "'Manual approval' kulcssz√≥ ‚Üí CodePipeline Manual Approval Action",
      "difficulty": "Easy"
    },
    {
      "id": 2,
      "question": "A DevOps team needs to store application artifacts in a centralized repository that supports npm, Maven, and PyPI packages. The repository should cache external packages to improve build performance. Which solution should they implement?",
      "options": [
        "Amazon S3 with versioning enabled",
        "AWS CodeArtifact with upstream repositories",
        "Elastic Container Registry (ECR)",
        "Amazon EFS with NFS shares"
      ],
      "correctIndex": 1,
      "explanation": {
        "hu": "CodeArtifact specifikusan package artifact repository, t√°mogatja npm, Maven, PyPI, NuGet-et. Upstream repositories funkci√≥ automatikusan cache-eli az external packages-eket, jelent≈ësen gyors√≠tva a build-eket.",
        "whyCorrect": "Package-specific service, multi-format support, upstream caching built-in",
        "whyWrong": [
          "S3 √°ltal√°nos storage, nincs package-specific features vagy upstream support",
          null,
          "ECR csak container images-re, nem software packages-re",
          "EFS file storage, nem artifact repository funkcionalit√°ssal"
        ]
      },
      "examTip": "'Multiple package types + cache external' ‚Üí CodeArtifact",
      "difficulty": "Easy"
    },
    {
      "id": 3,
      "question": "A CodeBuild project takes 15 minutes to complete due to dependency downloads. Which caching strategy would provide the MOST significant performance improvement?",
      "options": [
        "Enable S3 caching for node_modules directory",
        "Use local caching for source code",
        "Enable CloudFront caching",
        "Use EC2 instances instead of CodeBuild"
      ],
      "correctIndex": 0,
      "explanation": {
        "hu": "Dependencies (node_modules, Maven .m2) ritk√°n v√°ltoznak √©s gyakran nagy m√©ret≈±ek. S3 cache meg≈ërzi ezeket builds k√∂z√∂tt, √≠gy a dependency download f√°zis gyakorlatilag kihagyhat√≥. Ez jellemz≈ëen 50-70% id≈ëmegtakar√≠t√°st jelent.",
        "whyCorrect": "Dependencies largest/slowest part, S3 cache persists between builds",
        "whyWrong": [
          null,
          "Source code gyakran v√°ltozik, kevesebb benefit a cache-el√©sb≈ël",
          "CloudFront CDN service, nem relev√°ns CodeBuild-re",
          "EC2 nem oldja meg a dependency download probl√©m√°t, plusz operational overhead"
        ]
      },
      "examTip": "'Dependency download slow' ‚Üí S3 caching",
      "difficulty": "Medium"
    },
    {
      "id": 4,
      "question": "A deployment to production failed halfway through. The CodeDeploy deployment configuration is OneAtATime. What will happen to the instances that already received the new version?",
      "options": [
        "They will automatically roll back to the previous version",
        "They will keep the new version; remaining instances won't receive deployment",
        "All instances will roll back simultaneously",
        "The deployment will retry automatically after 5 minutes"
      ],
      "correctIndex": 1,
      "explanation": {
        "hu": "OneAtATime: 1 instance egyszerre. Ha fail ‚Üí STOP, nem automatic rollback. M√°r deployed instances megtartj√°k az √∫j verzi√≥t. Rollback manual vagy CloudWatch Alarm trigger-rel.",
        "whyCorrect": "Default CodeDeploy behavior on failure with OneAtATime",
        "whyWrong": [
          "Nincs automatic rollback OneAtATime-n√°l",
          null,
          "Nem t√∂rt√©nik automatic simultaneous rollback",
          "Nincs automatic retry"
        ]
      },
      "examTip": "CodeDeploy default = STOP on failure, NO automatic rollback",
      "difficulty": "Medium"
    },
    {
      "id": 5,
      "question": "An application needs to deploy to production with zero downtime and immediate rollback capability. Which deployment configuration should be used?",
      "options": [
        "AllAtOnce",
        "HalfAtATime",
        "Blue/Green",
        "Linear10PercentEvery10Minutes"
      ],
      "correctIndex": 2,
      "explanation": {
        "hu": "Blue/Green deployment k√©t teljes k√∂rnyezetet tart fenn. Blue (current) fut production-ben, Green (new) p√°rhuzamosan deploy-olva √©s tesztelve. Traffic instant switch (ELB/Route53) Green-re. Blue megmarad instant rollback-hez.",
        "whyCorrect": "Zero downtime (instant switch), immediate rollback (switch back to Blue), tested before cutover",
        "whyWrong": [
          "AllAtOnce = downtime van deployment alatt",
          "HalfAtATime = nem instant rollback, r√©szleges deployment k√∂zben lehet issue",
          null,
          "Linear = lass√∫ progressive rollout, nem instant rollback"
        ]
      },
      "examTip": "'Zero downtime + immediate rollback' ‚Üí Blue/Green",
      "difficulty": "Easy"
    },
    {
      "id": 6,
      "question": "A company wants to gradually roll out a new feature to 10% of users, monitor for 15 minutes, then automatically deploy to remaining 90% if no issues occur. Which approach should they use?",
      "options": [
        "CodeDeploy with Canary10Percent15Minutes deployment configuration",
        "CodeDeploy with Linear10PercentEvery15Minutes configuration",
        "API Gateway with Lambda weighted routing",
        "ALB with weighted target groups"
      ],
      "correctIndex": 0,
      "explanation": {
        "hu": "Canary deployment = Test group ‚Üí Full rollout. Canary10Percent15Minutes: 10% traffic ‚Üí wait 15 min ‚Üí If OK ‚Üí 90% remaining.",
        "whyCorrect": "Automated canary deployment with built-in monitoring and automatic rollout",
        "whyWrong": [
          null,
          "Linear = gradual increments (10%, 20%, 30%...), nem 10% ‚Üí 90%",
          "Manual traffic routing, nem automated deployment",
          "Manual traffic routing, nem automated deployment"
        ]
      },
      "examTip": "'10% test then 90%' ‚Üí Canary deployment",
      "difficulty": "Medium"
    },
    {
      "id": 7,
      "question": "A CodePipeline needs to deploy to multiple AWS accounts. What is the MOST secure way to provide cross-account access?",
      "options": [
        "Share IAM user credentials across accounts",
        "Use IAM roles with AssumeRole capability and KMS key policies",
        "Store credentials in Parameter Store and share the parameter",
        "Use Lambda with hardcoded credentials"
      ],
      "correctIndex": 1,
      "explanation": {
        "hu": "Cross-account deployment sz√ºks√©ges: 1) IAM Role target account-ban AssumeRole trust policy-vel, 2) S3 bucket policy target account access, 3) KMS key policy cross-account decrypt, 4) Temporary credentials via AssumeRole.",
        "whyCorrect": "Temporary credentials, no shared secrets, least privilege with KMS encryption",
        "whyWrong": [
          "Shared credentials = security risk, nem recommended",
          null,
          "Parameter Store sharing nem el√©g, KMS key kell",
          "Hardcoded credentials = worst practice"
        ]
      },
      "examTip": "'Cross-account' ‚Üí AssumeRole + KMS key policy",
      "difficulty": "Medium"
    },
    {
      "id": 8,
      "question": "Database credentials need to be rotated automatically every 30 days and used in a CodeBuild project. Which solution meets this requirement with the LEAST operational overhead?",
      "options": [
        "Store in Parameter Store SecureString with manual rotation",
        "AWS Secrets Manager with automatic rotation enabled",
        "Lambda function to rotate and store in S3",
        "Hardcode in buildspec.yml with encryption"
      ],
      "correctIndex": 1,
      "explanation": {
        "hu": "Secrets Manager = automatic rotation native support RDS/Redshift/DocumentDB-hez. CodeBuild reference: env.secrets-manager section.",
        "whyCorrect": "Automatic rotation built-in, least operational overhead, secure",
        "whyWrong": [
          "Parameter Store = NO automatic rotation",
          null,
          "Manual/complex solution, nem recommended",
          "Hardcode = insecure, nem best practice"
        ]
      },
      "examTip": "'Automatic rotation' ‚Üí Secrets Manager",
      "difficulty": "Easy"
    },
    {
      "id": 9,
      "question": "A buildspec.yml file needs to access a Docker Hub password securely during the build process. Which environment variable configuration should be used?",
      "options": [
        "variables: DOCKER_PASS: mypassword",
        "secrets-manager: DOCKER_PASS: dockerhub/password",
        "parameter-store: DOCKER_PASS: /dockerhub/password",
        "Both B and C are correct"
      ],
      "correctIndex": 3,
      "explanation": {
        "hu": "Mindk√©t megold√°s m≈±k√∂dik √©s biztons√°gos: secrets-manager vagy parameter-store section a buildspec.yml-ben.",
        "whyCorrect": "Both Secrets Manager and Parameter Store are secure methods for storing credentials",
        "whyWrong": [
          "Plaintext password = insecure",
          null,
          null,
          null
        ]
      },
      "examTip": "Secure credentials ‚Üí Secrets Manager vagy Parameter Store",
      "difficulty": "Easy"
    },
    {
      "id": 10,
      "question": "A CodePipeline stage occasionally fails due to transient network issues. How can the pipeline be configured to automatically retry the stage?",
      "options": [
        "Add a retry configuration in the stage action with retry count",
        "Use Lambda to monitor and restart the pipeline",
        "Enable automatic retry in CodePipeline settings",
        "CodePipeline automatically retries failed stages; no configuration needed"
      ],
      "correctIndex": 0,
      "explanation": {
        "hu": "CodePipeline action retry configuration: retryMode AUTOMATIC + numberOfRetries a stage action-ben.",
        "whyCorrect": "Native retry capability in CodePipeline actions",
        "whyWrong": [
          null,
          "Feleslegesen komplex Lambda megold√°s",
          "Nincs global automatic retry setting",
          "CodePipeline NEM retryol automatically by default"
        ]
      },
      "examTip": "Retry = explicit configuration sz√ºks√©ges",
      "difficulty": "Hard"
    },
    {
      "id": 11,
      "question": "A company needs to cache Docker layers between builds to reduce build time. Which CodeBuild cache configuration should be used?",
      "options": [
        "S3 cache mode with path /var/lib/docker",
        "Local cache mode with DOCKER_LAYER caching",
        "Both S3 and local caching together",
        "CloudFront cache with CodeBuild"
      ],
      "correctIndex": 1,
      "explanation": {
        "hu": "Docker layer caching: LOCAL cache type DOCKER_LAYER mode-dal. Meg≈ërzi Docker layers-t builds k√∂z√∂tt.",
        "whyCorrect": "Specifically designed for Docker layer caching",
        "whyWrong": [
          "S3 nem t√°mogatja Docker layer cache-t efficiently",
          null,
          "Nem kombin√°ld LOCAL-t S3-mal Docker layers-re",
          "CloudFront nem relev√°ns"
        ]
      },
      "examTip": "Docker layers ‚Üí LOCAL DOCKER_LAYER cache",
      "difficulty": "Medium"
    },
    {
      "id": 12,
      "question": "An application deployment requires approval from both the security team and operations team before production deployment. How should this be implemented in CodePipeline?",
      "options": [
        "Two sequential manual approval actions",
        "One manual approval action with two SNS topics",
        "Lambda function to verify approvals",
        "EventBridge rule with multiple targets"
      ],
      "correctIndex": 0,
      "explanation": {
        "hu": "K√©t k√ºl√∂n manual approval action = k√©t k√ºl√∂n approval sz√ºks√©ges egym√°s ut√°n. Build ‚Üí Test ‚Üí Approval (Security) ‚Üí Approval (Operations) ‚Üí Deploy.",
        "whyCorrect": "Two separate approvals ensure both teams must approve",
        "whyWrong": [
          null,
          "Egy approval = csak egy approval kell (b√°rmelyik team)",
          "Feleslegesen komplex",
          "EventBridge nem approval mechanism"
        ]
      },
      "examTip": "Multiple approvals ‚Üí Multiple approval actions",
      "difficulty": "Medium"
    },
    {
      "id": 13,
      "question": "Which CodeDeploy lifecycle event hook should be used to validate that the application is running correctly after deployment?",
      "options": [
        "ApplicationStart",
        "ValidateService",
        "AfterInstall",
        "BeforeInstall"
      ],
      "correctIndex": 1,
      "explanation": {
        "hu": "ValidateService = Application running check. Ez az utols√≥ hook, ahol health check-et futtathatsz. Ha fail ‚Üí rollback trigger.",
        "whyCorrect": "Designed specifically for post-deployment validation",
        "whyWrong": [
          "ApplicationStart csak elind√≠tja, nem valid√°lja",
          null,
          "AfterInstall t√∫l korai a teljes valid√°ci√≥hoz",
          "BeforeInstall a deployment el≈ëtt van"
        ]
      },
      "examTip": "Validation hook ‚Üí ValidateService",
      "difficulty": "Easy"
    },
    {
      "id": 14,
      "question": "A CodeBuild project needs to build multiple Docker images in parallel to save time. How should this be configured in buildspec.yml?",
      "options": [
        "Use separate build phases for each image",
        "Use batch build configuration with multiple buildspecs",
        "Create multiple CodeBuild projects",
        "Use concurrent Docker build commands in single build phase"
      ],
      "correctIndex": 1,
      "explanation": {
        "hu": "Batch build configuration lehet≈ëv√© teszi parallel builds k√ºl√∂nb√∂z≈ë buildspec-ekkel vagy environment v√°ltoz√≥kkal.",
        "whyCorrect": "Native parallel build capability in CodeBuild",
        "whyWrong": [
          "Separate phases = sequential, nem parallel",
          null,
          "Multiple projects = feleslegesen komplex",
          "Single phase = sequential execution"
        ]
      },
      "examTip": "Parallel builds ‚Üí Batch build configuration",
      "difficulty": "Hard"
    },
    {
      "id": 15,
      "question": "A deployment needs to update 20% of instances every 5 minutes. Which CodeDeploy configuration should be used?",
      "options": [
        "Linear20PercentEvery5Minutes",
        "Canary20Percent5Minutes",
        "AllAtOnce with 5-minute wait",
        "HalfAtATime with time-based triggers"
      ],
      "correctIndex": 0,
      "explanation": {
        "hu": "Linear deployment = gradual increments. Linear20PercentEvery5Minutes: 20% ‚Üí 40% ‚Üí 60% ‚Üí 80% ‚Üí 100% (5 perc l√©p√©senk√©nt).",
        "whyCorrect": "Exact match for requirement: 20% every 5 minutes",
        "whyWrong": [
          null,
          "Canary = 20% ‚Üí 80%, nem gradual",
          "AllAtOnce = nincs gradual rollout",
          "HalfAtATime = 50%, nem 20%"
        ]
      },
      "examTip": "Gradual percentage ‚Üí Linear deployment",
      "difficulty": "Easy"
    },
    {
      "id": 16,
      "question": "CodeArtifact repository needs to fetch packages from npm public registry. What is the maximum number of external connections allowed per repository?",
      "options": [
        "Unlimited",
        "1",
        "5",
        "10"
      ],
      "correctIndex": 1,
      "explanation": {
        "hu": "Maximum 1 external connection per repository. Ha multiple external sources kellenek, chain repositories-t haszn√°lj.",
        "whyCorrect": "AWS CodeArtifact service limit",
        "whyWrong": [
          "Nem unlimited",
          null,
          "Nem 5",
          "Nem 10"
        ]
      },
      "examTip": "External connection limit = 1",
      "difficulty": "Hard"
    },
    {
      "id": 17,
      "question": "A company uses AWS CodeArtifact for internal packages. Team A needs to share packages with Team B in a different AWS account. How should this be configured?",
      "options": [
        "Create IAM users in Team B's account",
        "Configure resource policy on CodeArtifact domain to allow Team B's account",
        "Publish packages to npm public registry",
        "Use S3 bucket with cross-account access"
      ],
      "correctIndex": 1,
      "explanation": {
        "hu": "Domain resource policy cross-account sharing-hez. Domain-level policy lehet≈ëv√© teszi m√°s account hozz√°f√©r√©s√©t.",
        "whyCorrect": "Native CodeArtifact cross-account sharing mechanism",
        "whyWrong": [
          "IAM users nem sz√ºks√©gesek, resource policy el√©g",
          null,
          "Public registry = nem private sharing",
          "S3 nem CodeArtifact replacement"
        ]
      },
      "examTip": "Cross-account CodeArtifact ‚Üí Domain resource policy",
      "difficulty": "Medium"
    },
    {
      "id": 18,
      "question": "During a CodePipeline execution, the Deploy stage needs information from the Build stage (e.g., image tag). How is this information passed between stages?",
      "options": [
        "Through CloudFormation parameters",
        "Using output artifacts and input artifacts",
        "Via S3 bucket notifications",
        "Through environment variables in Lambda"
      ],
      "correctIndex": 1,
      "explanation": {
        "hu": "Output artifacts ‚Üí Input artifacts. Build stage output artifact (pl. imageDetail.json) ‚Üí Deploy stage input artifact.",
        "whyCorrect": "Standard artifact passing mechanism in CodePipeline",
        "whyWrong": [
          "CloudFormation parameters nem stage k√∂z√∂tti kommunik√°ci√≥ra val√≥k",
          null,
          "S3 notifications nem artifact passing",
          "Lambda env vars nem persist across stages"
        ]
      },
      "examTip": "Stage communication ‚Üí Artifacts",
      "difficulty": "Medium"
    },
    {
      "id": 19,
      "question": "A deployment to production requires automated rollback if CPU utilization exceeds 80% within 10 minutes of deployment. How should this be implemented?",
      "options": [
        "CloudWatch Alarm with Lambda to trigger rollback",
        "CodeDeploy automatic rollback with CloudWatch Alarm trigger",
        "EventBridge rule monitoring CPU and triggering rollback",
        "Manual rollback based on CloudWatch dashboard"
      ],
      "correctIndex": 1,
      "explanation": {
        "hu": "CodeDeploy automatic rollback native feature. Konfigur√°lj CloudWatch alarm-ot, kapcsold a deployment-hez. Ha ALARM state ‚Üí automatic rollback.",
        "whyCorrect": "Native CodeDeploy feature, no custom code needed",
        "whyWrong": [
          "Lambda = feleslegesen komplex, native feature l√©tezik",
          null,
          "EventBridge nem rollback mechanism",
          "Manual = nem automated"
        ]
      },
      "examTip": "Automatic rollback ‚Üí CodeDeploy + CloudWatch Alarm",
      "difficulty": "Medium"
    },
    {
      "id": 21,
      "question": "An organization has multiple development teams. Each team needs isolated CodeArtifact repositories but should be able to share common packages. What architecture should be implemented?",
      "options": [
        "Separate domains for each team",
        "Single domain with multiple repositories and upstream repository for shared packages",
        "Single repository with team-based folders",
        "Separate AWS accounts for each team"
      ],
      "correctIndex": 1,
      "explanation": {
        "hu": "Single domain (org-level) + multiple repositories (team isolation) + upstream repository (shared packages). Domain lehet≈ëv√© teszi cross-repository sharing-et.",
        "whyCorrect": "Balances isolation with sharing using upstream repositories",
        "whyWrong": [
          "Separate domains = neh√©z sharing",
          null,
          "Single repository = nincs team isolation",
          "Separate accounts = feleslegesen komplex"
        ]
      },
      "examTip": "Team isolation + sharing ‚Üí Domain + multiple repos + upstream",
      "difficulty": "Hard"
    },
    {
      "id": 22,
      "question": "A CodePipeline needs to trigger on commits to specific branches in GitHub. Which trigger configuration should be used?",
      "options": [
        "Polling with branch filter",
        "EventBridge rule with GitHub webhook and branch filter",
        "Lambda function monitoring GitHub API",
        "CloudWatch Events with CodeCommit"
      ],
      "correctIndex": 1,
      "explanation": {
        "hu": "EventBridge = event-driven (recommended). GitHub webhook + EventBridge rule branch filter-rel.",
        "whyCorrect": "Event-driven, efficient, native integration",
        "whyWrong": [
          "Polling = legacy, inefficient",
          null,
          "Lambda = feleslegesen komplex",
          "CloudWatch Events CodeCommit-hoz van, nem GitHub-hoz"
        ]
      },
      "examTip": "GitHub trigger ‚Üí EventBridge + webhook",
      "difficulty": "Medium"
    },
    {
      "id": 23,
      "question": "Application code needs to reference the current build version during runtime. How should the build version be made available to the application in CodeBuild?",
      "options": [
        "Pass as environment variable using CODEBUILD_BUILD_NUMBER",
        "Write to a file during build and package with application",
        "Store in Parameter Store during build",
        "All of the above are valid approaches"
      ],
      "correctIndex": 3,
      "explanation": {
        "hu": "Mind a h√°rom valid approach, v√°laszt√°s use case-t≈ël f√ºgg: env var (runtime), file (packaged), Parameter Store (dynamic).",
        "whyCorrect": "Multiple valid approaches depending on requirements",
        "whyWrong": [
          null,
          null,
          null,
          null
        ]
      },
      "examTip": "Build version ‚Üí Multiple valid approaches",
      "difficulty": "Medium"
    },
    {
      "id": 24,
      "question": "A company needs to perform security scanning (SAST) on code before it enters the build stage. At which stage should the security scanning action be placed?",
      "options": [
        "Source stage",
        "Build stage at the beginning",
        "Between Build and Test stages",
        "Before Deploy stage"
      ],
      "correctIndex": 1,
      "explanation": {
        "hu": "SAST (Static Application Security Testing) = code analysis. Build stage elej√©n, build el≈ëtt. Early detection = cheaper fix.",
        "whyCorrect": "Early in pipeline for shift-left security",
        "whyWrong": [
          "Source stage = csak source pull, nincs analysis",
          null,
          "T√∫l k√©s≈ë, build ut√°n",
          "DAST ide val√≥, nem SAST"
        ]
      },
      "examTip": "SAST ‚Üí Build stage elej√©n",
      "difficulty": "Medium"
    },
    {
      "id": 25,
      "question": "CodeBuild needs to authenticate to Amazon ECR to push Docker images. What is the RECOMMENDED authentication method?",
      "options": [
        "Store ECR credentials in Secrets Manager",
        "Use IAM role attached to CodeBuild with ECR permissions",
        "Use docker login with hardcoded credentials",
        "Create IAM user with ECR access"
      ],
      "correctIndex": 1,
      "explanation": {
        "hu": "IAM role attached to CodeBuild = secure, no credentials. Pre_build: aws ecr get-login-password | docker login.",
        "whyCorrect": "Secure, no credentials, least privilege",
        "whyWrong": [
          "Felesleges Secrets Manager, IAM role jobb",
          null,
          "Hardcoded credentials = insecure",
          "IAM user = credentials, nem recommended"
        ]
      },
      "examTip": "ECR authentication ‚Üí IAM role",
      "difficulty": "Easy"
    },
    {
        "id": 26,
        "question": "Your team wants to enforce that no code is merged into main without at least 80% unit test coverage and passing static code analysis. What is the BEST way to enforce this in a CI pipeline?",
        "options": [
        "Require developers to manually check coverage and analysis before merge.",
        "Configure pull request checks in GitHub to block merge unless CodeBuild job passes with coverage report and static analysis results.",
        "Use post-merge webhook to fail build later if coverage is too low.",
        "Use CodePipeline to perform builds after merge and manually revert commit if tests fail."
        ],
        "correctIndex": 1,
        "explanation": {
        "hu": "Pull request merge el≈ëtti automatikus ellen≈ërz√©s biztos√≠tja, hogy csak megfelel≈ë min≈ës√©g≈± k√≥d ker√ºlj√∂n be a main √°gba.",
        "whyCorrect": "Automatikus PR check + build job = integr√°lt min≈ës√©g-ellen≈ërz√©s",
        "whyWrong": [
            "Manu√°lis ellen≈ërz√©s = emberi hib√°ra hajlamos",
            "Post-merge = m√°r beker√ºlt hib√°s k√≥d lehet",
            "Manual revert = k√©sleltetett visszah√≠v√°s"
        ]
        },
        "examTip": "Merge only after build + coverage + analysis pass",
        "difficulty": "Medium"
    },
    {
        "id": 27,
        "question": "During the pipeline build, your CodeBuild job downloads dependencies, compiles code and packages the artifact. You notice the dependency download step takes too long. Which caching option gives the BEST acceleration?",
        "options": [
        "S3 cache with full dependency folder",
        "CodeBuild local cache for source only",
        "CodeBuild local cache for Docker layer caching",
        "Disable dependency download and rely on developer machines"
        ],
        "correctIndex": 2,
        "explanation": {
        "hu": "Docker layer cache (LOCAL cache type DOCKER_LAYER) jelent≈ësen gyors√≠tja a build-id≈ët, ha Docker k√©pet √©p√≠tesz. Ha csak nat√≠v app, akkor S3 lehet, de Docker eset√©n a layer cache a legjobb.",
        "whyCorrect": "Docker layer cache = build time cs√∂kkent√©se",
        "whyWrong": [
            "S3 cache nem optimaliz√°l Docker layer-re",
            "Source only cache nem oldja meg a dependency let√∂lt√©st teljesen",
            "Kiz√°r√°s nem megold√°s"
        ]
        },
        "examTip": "Docker build speed ‚Üí use local DOCKER_LAYER cache",
        "difficulty": "Hard"
    },
    {
        "id": 28,
        "question": "Your CD pipeline deploys to staging then production. The operations team wants to delay production deployment until the first week of a release month. How do you implement schedule gating in the pipeline?",
        "options": [
        "Manually start production stage when ready.",
        "Use EventBridge rule to trigger pipeline only during first week, then automatic stages proceed.",
        "Use CodePipeline schedule action in pipeline JSON to run only during first week.",
        "Add conditional Lambda check at production stage to skip if not first week."
        ],
        "correctIndex": 1,
        "explanation": {
        "hu": "EventBridge rule schedule ‚Üí csak adott id≈ëszakban ind√≠tod a pipeline-t, √≠gy a production deploy automatikusan ekkor lehets√©ges.",
        "whyCorrect": "Automatiz√°lt id≈ëz√≠t√©s minim√°lis manu√°lis beavatkoz√°ssal",
        "whyWrong": [
            "Manu√°lis ind√≠t√°s = operat√≠v overhead",
            "CodePipeline nem rendelkezik nat√≠v schedule action-nel (EventBridge-vel kombin√°ci√≥ sz√ºks√©ges)",
            "Lambda conditional = felesleges komplex"
        ]
        },
        "examTip": "Scheduled deploy ‚Üí EventBridge rule triggers pipeline",
        "difficulty": "Medium"
    },
    {
        "id": 29,
        "question": "Your build produces a Docker image tagged with semantic versioning and a unique build number. You need to ensure that the same image is used through dev, staging and production environments without rebuilds. How should the pipeline be structured?",
        "options": [
        "Rebuild image in each environment with same tag.",
        "Build once, push image to ECR with digest, pass digest as parameter through pipeline and deploy identical image.",
        "Build and tag image ‚Äòlatest‚Äô, deploy to each environment and rely on approved checks.",
        "Store image outside AWS and deploy manually."
        ],
        "correctIndex": 1,
        "explanation": {
        "hu": "Azonos image (digest) minden k√∂rnyezetben biztos√≠tja a reproducibilit√°st √©s azt, hogy amit teszteltek, az ker√ºl produkci√≥ba.",
        "whyCorrect": "Build once, promote artifact across environments is best practice",
        "whyWrong": [
            "Rebuild = variancia",
            "Latest tag = nem deterministic",
            "Manual deploy = nem automatiz√°lt"
        ]
        },
        "examTip": "Promote same image ‚Üí build once, pass digest",
        "difficulty": "Hard"
    },
    {
        "id": 30,
        "question": "Your pipeline uses AWS CodePipeline and CodeBuild. There is a requirement that each pipeline execution must output a compliance report stored in S3 with encryption, and you need to track pipeline executions. Which additional configuration should you enable?",
        "options": [
        "Enable CloudTrail data events for S3 and CodePipeline.",
        "Enable pipeline notifications via SNS only.",
        "Store reports locally on build host.",
        "Use CloudWatch logs alone."
        ],
        "correctIndex": 0,
        "explanation": {
        "hu": "CloudTrail data-events for S3 + CodePipeline track every execution and storage event, megfelel a compliance k√∂vetelm√©nyeknek.",
        "whyCorrect": "Audit trail + encrypted S3 = compliance",
        "whyWrong": [
            "SNS nem audit trail",
            "Local storage nem megfelel enterprise compliance-nak",
            "CloudWatch logs ‚â† teljes audit trail"
        ]
        },
        "examTip": "Compliance ‚Üí CloudTrail data events + encrypted S3",
        "difficulty": "Medium"
    },
    {
        "id": 31,
        "question": "In your SDLC pipeline, you want to perform a smoke test automatically after deployment to production and roll back the deployment if the smoke test fails. Which service and method should you use for the smoke test?",
        "options": [
        "Use AWS Lambda invoked in CodePipeline as an action to run smoke test, then trigger rollback if failure.",
        "Use manual test by operations team after deployment.",
        "Add smoke test step within CodeBuild to run after deploy stage.",
        "Ignore smoke test and rely on monitoring alerts."
        ],
        "correctIndex": 0,
        "explanation": {
        "hu": "Lambda action a pipeline-ban lehet≈ëv√© teszi automatiz√°lt smoke testet √©s rollback-et, minim√°lis manu√°lis l√©p√©s.",
        "whyCorrect": "Automated smoke test action in pipeline = best practice",
        "whyWrong": [
            "Manual test = lass√∫",
            "Build phase ut√°n deploy-on k√≠v√ºl rossz helyen",
            "Monitoring alerts delayed"
        ]
        },
        "examTip": "Smoke test ‚Üí Lambda action in pipeline",
        "difficulty": "Hard"
    },
    {
        "id": 32,
        "question": "A development team commits infrastructure code frequently. They also want the pipeline to enforce cost-optimization best practices (e.g., no EC2 t2.large in production). Which tool should be integrated into the pipeline?",
        "options": [
        "AWS Config rules only.",
        "CloudFormation drift detection only.",
        "AWS CloudFormation Guard (cfn-guard) or AWS Config + policy as code integrated in pipeline.",
        "Manual review of Terraform code."
        ],
        "correctIndex": 2,
        "explanation": {
        "hu": "Policy as code (cfn-guard) vagy AWS Config + pipeline integr√°ci√≥ biztos√≠tja, hogy infra-code megfeleljen a cost-opt k√∂vetelm√©nyeknek automatiz√°ltan.",
        "whyCorrect": "Automated policy-as-code integration best practice",
        "whyWrong": [
            "AWS Config alone = post-deploy drift only",
            "Drift detection = ut√°n-ellen≈ërz√©s, nem pre-deploy",
            "Manual review = kock√°zatos"
        ]
        },
        "examTip": "Cost-optimization infra code ‚Üí policy as code",
        "difficulty": "Medium"
    },
    {
        "id": 33,
        "question": "You have a monorepo with multiple microservices and want to trigger builds only for services affected by a commit. Which approach will you implement?",
        "options": [
        "Trigger build for all services on every commit.",
        "Use code ownership files to manually list impacted services.",
        "Use dependency graph tooling (e.g., AWS CodeCatalyst or open-source) to determine impacted services and trigger only those builds.",
        "Schedule nightly full builds and avoid per-commit builds."
        ],
        "correctIndex": 2,
        "explanation": {
        "hu": "Dependency graph tooling az √©rintett szolg√°ltat√°sokat automatikusan detekt√°lja, cs√∂kkenti a build-id≈ët √©s er≈ëforr√°s-felhaszn√°l√°st.",
        "whyCorrect": "Dynamic impact detection = efficient CI",
        "whyWrong": [
            "Build all = t√∫l sok id≈ë",
            "Manual code-ownership list = hib√°ra hajlamos",
            "Nightly full build = nem per-commit"
        ]
        },
        "examTip": "Monorepo impact ‚Üí dependency graph trigger builds",
        "difficulty": "Hard"
    },
    {
        "id": 34,
        "question": "Your pipeline deploys to production using Blue/Green strategy but you want to ensure the old environment is retained for at least 24 hours before final cutover. What change should you make?",
        "options": [
        "Delete Blue environment immediately after Green becomes healthy.",
        "Configure CodeDeploy with termination delay of old environment for 24 hours.",
        "Switch to AllAtOnce deployment.",
        "Manually perform cut-over after 24 hours."
        ],
        "correctIndex": 1,
        "explanation": {
        "hu": "CodeDeploy terminationDelay parameter lehet≈ëv√© teszi, hogy az eredeti k√∂rnyezet 24 √≥r√°ig el√©rhet≈ë maradjon rollback-hez vagy gyors switch-hez.",
        "whyCorrect": "Native parameter a Blue/Green deploy-ban",
        "whyWrong": [
            "Azonnali t√∂rl√©s = nincs rollback ablak",
            "AllAtOnce = nem Blue/Green strat√©gia",
            "Manu√°lisan = nem automatiz√°lt"
        ]
        },
        "examTip": "Blue/Green ‚Üí retention of old environment for recovery",
        "difficulty": "Medium"
    },
    {
        "id": 35,
        "question": "In a CI/CD pipeline using CodePipeline, you want to avoid pipeline flapping (rapid success/failure cycles) when external APIs are down temporarily. Which mechanism should be introduced?",
        "options": [
        "Ignore the failures and continue.",
        "Use Lambda retry logic within pipeline steps.",
        "Use CodePipeline action retry configuration (retry count and backoff) and adjust timeout to absorb transient failures.",
        "Switch to manual pipeline triggers only."
        ],
        "correctIndex": 2,
        "explanation": {
        "hu": "CodePipeline action configuration t√°mogatja retryMode √©s numberOfRetries param√©tereket, amelyek seg√≠tenek elnyelni √°tmeneti hib√°kat √©s stabilabb pipeline-t eredm√©nyeznek.",
        "whyCorrect": "Native retry + backoff √∂sszehangolt megold√°s",
        "whyWrong": [
            "Ignore = nem kezel hib√°t",
            "Lambda retry = felesleges komplex",
            "Manu√°lis trigger = cs√∂kkenti automatiz√°l√°st"
        ]
        },
        "examTip": "Pipeline stability ‚Üí action retry config",
        "difficulty": "Hard"
    },
    {
        "id": 36,
        "question": "Your team is deploying infrastructure using Terraform and wants to ensure that any change to production infrastructure can be rolled back safely. What is the BEST practice to enable this?",
        "options": [
        "Allow direct terraform apply to production branch without review",
        "Use Terraform Cloud with versioned workspaces and state versioning enabled, and trigger rollback by selecting previous workspace version",
        "Store state file locally and backup daily",
        "Use manual change control board for production changes only"
        ],
        "correctIndex": 1,
        "explanation": {
        "hu": "Terraform Cloud workspaces √°llapot-verzi√≥z√°ssal √©s rollback lehet≈ës√©ggel biztos√≠tja, hogy az √©l≈ë infrastrukt√∫r√°t vissza lehessen √°ll√≠tani kor√°bbi √°llapotra.",
        "whyCorrect": "Automatiz√°lt state versioning + rollback t√°mogat√°s a legjobb gyakorlat",
        "whyWrong": [
            "K√∂zvetlen apply = nincs review, kock√°zatos",
            "Helyi backup = nem automatiz√°lt √©s sk√°l√°zhat√≥",
            "Manual change control board = operat√≠v overhead"
        ]
        },
        "examTip": "Infra as code rollback ‚Üí Terraform Cloud + state versioning",
        "difficulty": "Hard"
    },
    {
        "id": 37,
        "question": "A microservices alkalmaz√°s CI pipeline-ja tartalmaz build, test √©s deploy l√©p√©seket. A csapat most bevezeti a feature-flag-et √©s dark-launch-t, hogy funkci√≥kat fokozatosan enged√©lyezzenek. Milyen v√°ltoztat√°st javasolsz a pipeline-ban?",
        "options": [
        "Deploy minden funkci√≥val egyszerre, majd manu√°lisan kapcsolj√°k ki, ha probl√©ma",
        "Integr√°lj feature-flag telep√≠t√©st a pipeline-ban: build ‚Üí test ‚Üí deploy ‚Üí feature-flag rollout kontroll",
        "Ne haszn√°ljatok feature-flag-et, csak gyors deploy-t",
        "Telep√≠tsen minden build √∫j szolg√°ltat√°st k√ºl√∂n pipeline-ban"
        ],
        "correctIndex": 1,
        "explanation": {
        "hu": "Feature-flag rollout kontroll-al a pipeline r√©szek√©nt automatikusan lehet fokozatosan enged√©lyezni funkci√≥kat, cs√∂kkentve a kock√°zatot √©s fenntartva CI/CD sebess√©get.",
        "whyCorrect": "Automatiz√°l√°s + fokozatos rollout = best practice",
        "whyWrong": [
            "Mind egyszerre = t√∫l nagy kock√°zat",
            "Nem haszn√°lni = elmaradott gyakorlat",
            "K√ºl√∂n pipeline = t√∫l sok overhead"
        ]
        },
        "examTip": "Feature-flag + dark-launch ‚Üí integrate pipeline",
        "difficulty": "Medium"
    },
    {
        "id": 38,
        "question": "Your CI/CD pipeline currently uses a monolithic codebase and takes over 30 minutes for a build. The team moves to microservices and wants to reduce build time drastically. Which approach will have the MOST impact?",
        "options": [
        "Continue building monolith but on faster hardware",
        "Convert to microservices and trigger only impacted services builds via dependency mapping",
        "Delay builds to off-peak hours",
        "Remove tests to speed up build"
        ],
        "correctIndex": 1,
        "explanation": {
        "hu": "Microservicesre v√°lt√°s + dependency mapping, ahol csak az √©rintett szolg√°ltat√°s √©p√ºl √∫jra, nagy m√©rt√©kben cs√∂kkenti az √©p√≠t√©si id≈ët √©s optimaliz√°lja folyamatos integr√°ci√≥t.",
        "whyCorrect": "Build only what changed = significant time reduction",
        "whyWrong": [
            "Faster hardware = k√∂lts√©ges √©s nem a root issue",
            "Off-peak = k√©sleltet√©s n√∂vekszik",
            "Teszt elt√°vol√≠t√°sa = min≈ës√©g romlik"
        ]
        },
        "examTip": "Microservices + change detection = faster CI",
        "difficulty": "Hard"
    },
    {
        "id": 39,
        "question": "A deployment k√∂rnyezetek (dev, staging, prod) k√∂z√∂tt a csapat szeretn√© biztos√≠tani, hogy ugyanazt a bin√°rist utolj√°ra tesztelj√©k, majd deploy-olj√°k. Milyen megold√°st javasolsz?",
        "options": [
        "K√©sz√≠ts √∫j build minden k√∂rnyezetre",
        "Haszn√°lj build artifact-ot, √©s prom√≥t√°ld dev ‚Üí staging ‚Üí prod an√©lk√ºl, hogy √∫jra buildeln√©d",
        "Deploy-olj dev-be, majd rebuild stagingre, v√©g√ºl prodba",
        "Manual build √∫jra staging √©s prod el≈ëtt"
        ],
        "correctIndex": 1,
        "explanation": {
        "hu": "Azonos build artifact prom√≥ci√≥ja biztos√≠tja, hogy amit teszteltek, az ker√ºlj√∂n produkci√≥ba ‚Äî ezzel n√∂veled a megb√≠zhat√≥s√°got √©s cs√∂kkented a build varianci√°t.",
        "whyCorrect": "What you test is what you deploy = best practice",
        "whyWrong": [
            "√öj build minden k√∂rnyezetre = variancia",
            "Rebuild staging el≈ëtt = ism√©telt √°llapot",
            "Manual build = nem automatiz√°lt"
        ]
        },
        "examTip": "Promote same artifact ‚Üí no rebuild between envs",
        "difficulty": "Medium"
    },
    {
        "id": 40,
        "question": "Your pipeline uses AWS CodePipeline and you want to enforce that every merge to main triggers the pipeline and no direct commits are allowed. Which Git configuration and pipeline combination should you use?",
        "options": [
        "Allow direct commits and periodically run pipeline manually",
        "Use GitHub branch protection rules: require pull request, status checks pass, then Webhook triggers CodePipeline",
        "Use push triggers only on develop branch",
        "Use manual review board after commit"
        ],
        "correctIndex": 1,
        "explanation": {
        "hu": "Branch protection + status checks + webhook-triggered pipeline biztos√≠tja, hogy csak ellen≈ërz√∂tt k√≥d ker√ºlj√∂n be, √©s azonnal pipeline induljon.",
        "whyCorrect": "Integration of Git workflow + pipeline best practice",
        "whyWrong": [
            "Direct commits = nem kontroll√°lt",
            "Push on develop = main nem v√©dett",
            "Manual review board = k√©sleltetett"
        ]
        },
        "examTip": "Branch protection + pipeline trigger",
        "difficulty": "Easy"
    },
    {
        "id": 41,
        "question": "A CodeBuild projektet 12 MB/s-n√©l nagyobb f√°jlok let√∂lt√©se lass√≠tja. A build-spec down-loading l√©p√©sei sor√°n az S3 mell√© CloudFront-ot javasolnak. Haszn√°lhat√≥ ez a build optimaliz√°l√°sra? Mi a VAL√ìBAN legjobb megold√°s?",
        "options": [
        "Igen, CloudFront gyors√≠t az S3-ra val√≥ let√∂lt√©seknek",
        "Nem, ink√°bb haszn√°lj S3 Transfer Acceleration-t √©s CodeBuild caching-et",
        "Igen, de csak ha VPC-n bel√ºl vagy",
        "Nem, csak EC2-vel lehet gyors√≠tani"
        ],
        "correctIndex": 1,
        "explanation": {
        "hu": "S3 Transfer Acceleration + CodeBuild caching (pl. LOCAL_SOURCE vagy S3 cache) jobb build-optimaliz√°l√°s, mint CloudFront, amely nem garant√°ltan haszn√°lhat√≥ build folyamatban.",
        "whyCorrect": "Kifejezetten build-munk√°ra optimaliz√°lt megold√°s",
        "whyWrong": [
            "CloudFront nem build-let√∂lt√©sre optimaliz√°lt",
            null,
            "VPC-n bel√ºl nem relev√°ns let√∂lt√©si sebess√©g",
            "EC2 nem felt√©tlen megold√°s"
        ]
        },
        "examTip": "Download speed ‚Üí S3 Transfer Acceleration + caching",
        "difficulty": "Hard"
    },
    {
        "id": 42,
        "question": "Your development team uses SAM (Serverless Application Model) and wants to include infrastructure unit tests (e.g., for AWS Lambda resource definitions) in the CI pipeline. What is the BEST way to integrate this?",
        "options": [
        "Deploy to AWS and manually test resources",
        "Write unit tests with AWS SAM CLI ‚Äòsam validate‚Äô and ‚Äòsam build ‚Äìcached‚Äô, run in CodeBuild before deployment",
        "Skip infra tests and rely on production monitoring",
        "Use manual inspection of CloudFormation templates"
        ],
        "correctIndex": 1,
        "explanation": {
        "hu": "Infra-unit tesztek: SAM CLI validate + build ‚Üí CI-integr√°ci√≥ban futtathat√≥. Ez kor√°n detekt√°lja hib√°s infra-k√≥dokat.",
        "whyCorrect": "Automatiz√°lt infra validation a pipeline-ban",
        "whyWrong": [
            "Deploy teszt ut√°n = k√©s≈ëi detection",
            "Skip = kock√°zat",
            "Manual inspection = lass√∫ √©s hib√°ra hajlamos"
        ]
        },
        "examTip": "Infra unit tests ‚Üí SAM CLI in CI",
        "difficulty": "Medium"
    },
    {
        "id": 43,
        "question": "A pipeline build sor√°n t√∂bb r√©gi√≥s komponensek (us-east-1 √©s eu-west-1) k√∂z√∂tti artifact replik√°ci√≥ sz√ºks√©ges az al√°bbi k√∂vetelm√©nyekkel: alacsony latency, adatduplik√°l√°s n√©lk√ºl. Melyik architekt√∫r√°t javaslod?",
        "options": [
        "K√ºl√∂n pipeline r√©gi√≥nk√©nt, nincs replik√°ci√≥",
        "K√∂zponti r√©gi√≥ban artifakt t√°rol√°s √©s S3 Cross-Region Replication (CRR) minden build ut√°n",
        "Build minden r√©gi√≥ban √∫jra egym√°st√≥l f√ºggetlen√ºl",
        "Use ECR image rep√≥ csak egy r√©gi√≥ban"
        ],
        "correctIndex": 1,
        "explanation": {
        "hu": "S3 CRR biztos√≠tja, hogy az artifakt m√°s r√©gi√≥ban is el√©rhet≈ë alacsony k√©sleltet√©ssel, adatduplik√°l√°s kontroll alatt, centraliz√°lt folyamat mellett.",
        "whyCorrect": "CRR = sk√°l√°zhat√≥ multi-region artifact storage",
        "whyWrong": [
            "R√©gi√≥nk√©nt k√ºl√∂n pipeline = overhead",
            "√öjra build = dr√°ga id≈ëben √©s er≈ëforr√°sban",
            "ECR csak k√©pekhez, nem √°ltal√°nos artifakt"
        ]
        },
        "examTip": "Multi-region artifact ‚Üí S3 CRR",
        "difficulty": "Hard"
    },
    {
        "id": 44,
        "question": "Your pipeline includes static code analysis, license compliance scanning and container image vulnerability scanning. The security team wants a consolidated dashboard of all issues per build. What is the BEST way to achieve this?",
        "options": [
        "Send results by email to security team",
        "Send each scan result individ- ually to CloudWatch Logs",
        "Push all scan results into Amazon Security Hub findings and build a QuickSight dashboard",
        "Use local logs only"
        ],
        "correctIndex": 2,
        "explanation": {
        "hu": "Security Hub integr√°ci√≥val k√∂zponti scan eredm√©nyek kezelhet≈ëk, QuickSight-on kereszt√ºl vizualiz√°lhat√≥k. Automatiz√°lt, sk√°l√°zhat√≥ √©s vizu√°lis megold√°s.",
        "whyCorrect": "Security Hub + QuickSight = integr√°lt eredm√©nykezel√©s",
        "whyWrong": [
            "Email = nem sk√°l√°zhat√≥",
            "CloudWatch logs = nem konszolid√°lt dashboard",
            "Local logs = nem el√©g enterprise"
        ]
        },
        "examTip": "Security scans ‚Üí Security Hub + QuickSight",
        "difficulty": "Medium"
    },
    {
        "id": 45,
        "question": "A pipeline build ut√°n a QA csapat egy k√ºl√∂n sandbox k√∂rnyezetben futtat teljes end-to-end teszteket. A sandbox ugyanakkora mint a prod, de k√∂lts√©g√ºk √≥ri√°si. Mire javasoln√°d optimaliz√°lni?",
        "options": [
        "Tartsd v√°ltozatlanul, mert prod-like k√∂rnyezet kell",
        "Haszn√°lj spot-p√©ld√°nyokat √©s auto-scale-t a sandbox-ban, hogy csak sz√ºks√©g idej√©n legyen kapacit√°s",
        "Cs√∂kkentsd a tesztek sz√°m√°t",
        "Futtasd csak heti egyszer"
        ],
        "correctIndex": 1,
        "explanation": {
        "hu": "Spot-p√©ld√°nyok + auto-scale lehet≈ës√©get biztos√≠tanak, hogy tesztk√∂rnyezet k√∂lts√©ghat√©kony, m√©gis nagy kapacit√°s√∫ legyen amikor sz√ºks√©ges.",
        "whyCorrect": "K√∂lts√©goptimaliz√°l√°s + sk√°l√°zhat√≥ k√∂rnyezet",
        "whyWrong": [
            "V√°ltozatlan k√∂lts√©ges",
            "Teszt cs√∂kkent√©se = kock√°zat",
            "√ârdekes esem√©nyek ritk√°bban kapnak √©szlel√©st"
        ]
        },
        "examTip": "Sandbox cost optimisation ‚Üí spot + autoscale",
        "difficulty": "Medium"
    },
    {
        "id": 46,
        "question": "Your CI pipeline deploys to an Amazon ECS cluster. You want to enable automatic rollback if the deployed task fails health checks within 5 minutes. Which mechanism should you use?",
        "options": [
        "Use CloudWatch alarm + Lambda to stop tasks",
        "Configure ECS deployment controller type to CODE_DEPLOY and use Blue/Green with automatic rollback",
        "Monitor health manually and revert tasks",
        "Use raw ECS service with ‚Äôminimum healthy percent‚Äô only"
        ],
        "correctIndex": 1,
        "explanation": {
        "hu": "ECS Blue/Green deploy (CODE_DEPLOY) t√°mogat rollback-et √©s be√©p√≠tett eg√©szs√©g-ellen≈ërz√©st a szolg√°ltat√°s-v√°lt√°s sor√°n.",
        "whyCorrect": "Native rollback supported Blue/Green on ECS",
        "whyWrong": [
            "Lambda = felesleges komplex",
            "Manual revert = nem automatiz√°lt",
            "Raw ECS szolg√°ltat√°s nem ad teljes rollback mechanizmust"
        ]
        },
        "examTip": "ECS automatic rollback ‚Üí CODE_DEPLOY Blue/Green",
        "difficulty": "Hard"
    },
    {
        "id": 47,
        "question": "In your pipeline definition you want to ensure that only commits from authors with approved email domains are allowed to trigger builds. What‚Äôs the BEST way to implement this automation?",
        "options": [
        "Ignore commit author domain",
        "Use AWS Lambda in CodePipeline as pre-validation step to check author email domain",
        "Use GitHub branch protection rules only",
        "Manually check commit authors"
        ],
        "correctIndex": 1,
        "explanation": {
        "hu": "Lambda pre-validation step a pipeline-ban lehet≈ëv√© teszi, hogy commit author email domain-j√©t ellen≈ërizhesd automatiz√°ltan, miel≈ëtt build elindulna.",
        "whyCorrect": "Automatiz√°lt pre-validation = integr√°lt √©s megb√≠zhat√≥",
        "whyWrong": [
            "Ignore = nincs kontroll",
            "Branch protect nem domain-szint≈± author ellen≈ërz√©s",
            "Manual = hib√°ra hajlamos"
        ]
        },
        "examTip": "Author domain check ‚Üí Lambda pre-validation in pipeline",
        "difficulty": "Medium"
    },
    {
        "id": 48,
        "question": "Your CI/CD pipeline triggers on pull request merges and builds artifacts. You need to ensure that commits with high-severity vulnerability findings do not get merged. Which approach should you use?",
        "options": [
        "Merge then scan and fix later",
        "Fail the pull request build if vulnerability severity ‚â• HIGH using CodeBuild integration with Snyk or Amazon CodeGuru and block merge via GitHub status check",
        "Scan only production artefacts",
        "Ignore vulnerabilities and fix in production"
        ],
        "correctIndex": 1,
        "explanation": {
        "hu": "Pull request build integr√°l√°sa statikus vuln scanning-gel √©s GitHub status check blokkol√°sa, ha HIGH vagy CRITICAL tal√°lat van, biztos√≠tja a ‚Äòshift-left security‚Äô modellt.",
        "whyCorrect": "Automatiz√°lt security gate merge-kor",
        "whyWrong": [
            "Merge then scan = t√∫l k√©s≈ën",
            "Only production = kev√©sb√© hat√©kony",
            "Ignore = nem felel meg security k√∂vetelm√©nyeknek"
        ]
        },
        "examTip": "Security gate on merge ‚Üí block if HIGH vulnerabilities",
        "difficulty": "Hard"
    },
    {
        "id": 49,
        "question": "You have a CodeBuild project that builds and packages artifacts. The security team requires that the build logs must be encrypted and archived for 7 years in a cost-effective way. What architecture should you implement?",
        "options": [
        "Leave logs in CloudWatch only",
        "Configure CodeBuild to export logs to an S3 bucket with bucket encryption (KMS CMK), lifecycle transition to Glacier Deep Archive after 30 days, retain 7 years",
        "Store logs in EBS volumes attached to build host",
        "Send logs to third-party logging service"
        ],
        "correctIndex": 1,
        "explanation": {
        "hu": "CloudWatch ‚Üí S3 export with KMS CMK encryption + lifecycle to Glacier Deep Archive = k√∂lts√©ghat√©kony √©s megfelel hossz√∫ t√°v√∫ retention-nek.",
        "whyCorrect": "Secure, compliant retention architecture",
        "whyWrong": [
            "CloudWatch alone nem 7 √©v retention k√∂lts√©ghat√©konyan",
            "EBS = nincs hossz√∫-t√°v√∫ archiv√°l√°s",
            "Third-party = extra k√∂lts√©g, compliance kock√°zat"
        ]
        },
        "examTip": "Log retention ‚Üí S3 encryption + Glacier Deep Archive",
        "difficulty": "Medium"
    },
    {
        "id": 50,
        "question": "Your pipeline has grown to a point where there are dozens of repositories, builds and deployments. The team needs to track build metrics (duration, success rate, cost) and visualize trends across services. What is the BEST approach?",
        "options": [
        "Export CodeBuild metrics manually to Excel",
        "Use AWS CodeBuild Batch builds + CloudWatch metric filters + Amazon QuickSight dashboard to visualize trends",
        "Ignore metrics and rely on manual review meetings",
        "Use CloudWatch dashboards only"
        ],
        "correctIndex": 1,
        "explanation": {
        "hu": "Batch builds + CloudWatch metric filters + QuickSight seg√≠ts√©g√©vel automatiz√°lhat√≥ a metrikagy≈±jt√©s √©s vizualiz√°ci√≥, sk√°l√°zhat√≥ m√≥don.",
        "whyCorrect": "Automated metric collection + interactive dashboard = best practice",
        "whyWrong": [
            "Excel = manual, nem sk√°l√°zhat√≥",
            "Ignore = nem best practice",
            "CloudWatch dashboards = kevesebb vizualiz√°ci√≥s lehet≈ës√©g"
        ]
        },
        "examTip": "Build metrics visualization ‚Üí QuickSight + CloudWatch filters",
        "difficulty": "Hard"
    },
    {
        "id": 51,
        "question": "A development team uses a feature branching strategy in Git and merges completed features into a ‚Äòmain‚Äô branch once reviewed. They want their pipeline (AWS CodePipeline) to automatically trigger on merge, run unit tests, security scans, and deploy to a staging environment, but only deploy to production after manual approval. Which setup is most efficient?",
        "options": [
        "Configure a webhook for Git to trigger CodePipeline on main branch pushes, add CodeBuild for unit tests, a manual approval action, then a CodeDeploy stage to production.",
        "Schedule CodePipeline to run every hour, include unit tests and security scans, and then deploy to production automatically.",
        "Use CodeCommit triggers to start a Lambda function that orchestrates unit tests, manual approval and then invokes CodeDeploy.",
        "Create two separate pipelines: one auto-deploys to staging on branch merge, another manually triggered deploys to production."
        ],
        "correctIndex": 0,
        "explanation": {
        "hu": "Webhook trigger + CodePipeline automatikus l√©p√©sek, majd manual approval = legkevesebb operat√≠v overheadgel √©s inline CI/CD integr√°ci√≥val.",
        "whyCorrect": "Webhook trigger biztos√≠tja az azonnali ind√≠t√°st, a pipeline l√©p√©sek integr√°ltan kezelik testet, √©s a j√≥v√°hagy√°s el≈ëzi meg a produkci√≥ra l√©p√©st.",
        "whyWrong": [
            "√ìr√°nk√©nti fut√°s nem val√≥s idej≈±, √©s nem automatiz√°lt el√©g.",
            "Custom Lambda orchestration feleslegesen komplex.",
            "K√©t pipeline fenntart√°sa t√∂bb overheadet jelent."
        ]
        },
        "examTip": "‚Äûautomatikus CI + staging + manual approval‚Äù ‚Üí Webhook + CodePipeline + Manual Approval",
        "difficulty": "Hard"
    },
    {
        "id": 52,
        "question": "A CodeBuild project builds a Docker image and pushes it to Amazon Elastic Container Registry (ECR). The build spec includes unit tests, integration tests, and image scan. After the build, the image should automatically be deployed to a non-prod cluster. Which buildspec configuration is BEST to optimize time while ensuring quality?",
        "options": [
        "Run unit tests and image build in parallel phases in buildspec, then push image and deploy.",
        "Run unit tests, then integration tests, then image build, then push and deploy, all sequentially.",
        "Build image first, push to ECR, then run tests by pulling the image in a separate CodeBuild project.",
        "Run image build and push in one phase, then have a separate pipeline for tests on the image."
        ],
        "correctIndex": 2,
        "explanation": {
        "hu": "K√ºl√∂n f√°zisban tesztelni a m√°r √©p√≠tett k√©pet biztos√≠tja, hogy amit deploy-olsz, az azonos mint amit tesztelt√©l. Ez cs√∂kkenti a build time-ot √©s n√∂veli a megb√≠zhat√≥s√°got.",
        "whyCorrect": "Az image el≈ëbb k√©sz√ºl, majd ugyanaz a image ker√ºl tesztel√©sre, √≠gy minimaliz√°lod a vari√°ci√≥t √©s k√©s≈ëbbi hib√°z√°s es√©ly√©t.",
        "whyWrong": [
            "Parallel unit/test + build keverheti a v√°ltozatokat.",
            "T√∫l hossz√∫ sorrend sequential m√≥don lass√≠t.",
            "K√ºl√∂n pipeline n√∂veli az operat√≠v overheadet."
        ]
        },
        "examTip": "‚ÄûBuild image el≈ëbb, azt√°n teszteld ugyanazt az image-t‚Äù",
        "difficulty": "Hard"
    },
    {
        "id": 53,
        "question": "Your team maintains three environments (dev, staging, production) with the same pipeline. They want to promote the same artifact through environments without rebuilding at each stage. How should you implement this?",
        "options": [
        "Add separate build steps in CodePipeline for each environment that reuse the build output artifact.",
        "Re-build in each environment stage to ensure environment-specific configuration.",
        "Use a single pipeline with stages: build ‚Üí test ‚Üí deploy to dev; approval ‚Üí deploy same artifact to staging; approval ‚Üí deploy same artifact to production.",
        "Use different pipelines for each environment to match each configuration."
        ],
        "correctIndex": 2,
        "explanation": {
        "hu": "Azonos artifact-ot v√©gigjuttatni a pipeline-n √°t minimaliz√°lja a build varianci√°t √©s n√∂veli az ism√©telhet≈ës√©get.",
        "whyCorrect": "Single pipeline √©s prom√≥ci√≥s modell biztos√≠tja a ‚Äòwhat you test is what you deploy‚Äô elvet.",
        "whyWrong": [
            "Separate build l√©p√©sek n√∂velik a varianci√°t.",
            "Re-build minden k√∂rnyezetben feleslegesen n√∂veli id≈ët.",
            "T√∂bb pipeline operat√≠v overheadet okoz."
        ]
        },
        "examTip": "‚ÄûPromote same artifact‚Äù ‚Üí Single pipeline, test ‚Üí approval ‚Üí promote.",
        "difficulty": "Medium"
    },
    {
        "id": 54,
        "question": "A pipeline deploy ut√°n monitoring √©s roll-back strat√©gia sz√ºks√©ges. Mit tegy√©l, hogy automatikus rollback legyen, ha √∫j k√≥d hib√°t produk√°l productionben?",
        "options": [
        "K√©sz√≠ts CloudWatch alarm-ot, konfigur√°ld √∫gy, hogy trigger-olja a rollback-et a AWS CodeDeploy konfigur√°ci√≥ban.",
        "Haszn√°lj Lambda-t, ami figyeli a logokat √©s manu√°lisan rollback-et hajt v√©gre.",
        "√Åll√≠ts be EventBridge szab√°lyt, ami minden deploy ut√°n figyeli a verzi√≥t √©s manu√°lisan visszav√°lt.",
        "Konfigur√°lj CodePipeline-ban monitoring m≈±veletet, ami figyeli √©s ha hiba akkor manual approval-t k√©r."
        ],
        "correctIndex": 0,
        "explanation": {
        "hu": "CodeDeploy t√°mogatja CloudWatch alarm-okhoz kapcsol√≥d√≥ automatic rollback-et. Ez a legautomatikusabb √©s legkevesebb operat√≠v overheadel m≈±k√∂d≈ë megold√°s.",
        "whyCorrect": "Native rollback integr√°lhat√≥ CloudWatch alarm-okkal, nincs sz√ºks√©g extra Lambda-ra.",
        "whyWrong": [
            "Lambda megold√°s m≈±veletig√©nyes.",
            "EventBridge nem c√©lzott rollback mechanizmus.",
            "Manual review marad-lehet≈ës√©g, de nem automatikus."
        ]
        },
        "examTip": "‚ÄûAutomatic rollback‚Äù ‚Üí CloudWatch alarm + CodeDeploy setting",
        "difficulty": "Hard"
    },
    {
        "id": 55,
        "question": "A CI pipeline tartalmazza a k√∂vetkez≈ë l√©p√©seket: build, unit test, integration test, package, publish artifact. A dev csapat most azt k√©ri, hogy a publish-n√©l automatikusan legyen version tag (pl. 1.0.0-20251025-123). Mi a LEGjobb m√≥dja az automatiz√°l√°sra?",
        "options": [
        "Haszn√°lj CodeBuild buildspec-ben k√∂rnyezeti v√°ltoz√≥t, amely gener√°lja a verzi√≥-taget, majd Git tag-et √©s push.",
        "K√©rj manu√°lis verzi√≥jobbv√°hagy√°st a csapat r√©sz√©r≈ël, √©s manu√°lisan k√©sz√≠ts Git tag-et.",
        "Hozz l√©tre Lambda-t, ami figyeli a Git f≈ë√°gat √©s automatikusan tag-el.",
        "A fejleszt≈ëk maguk adj√°k meg a verzi√≥-taget minden merge- el≈ëtt."
        ],
        "correctIndex": 0,
        "explanation": {
        "hu": "Automatikusan gener√°lt tag build-f√°zisban biztos√≠tja, hogy minden artifact reproducible m√≥don kap verzi√≥t, √©s nincs manu√°lis l√©p√©s.",
        "whyCorrect": "CodeBuild buildspec-ben fut√≥ tag-gener√°l√°s automatiz√°l, low overhead-del.",
        "whyWrong": [
            "Manu√°lis j√≥v√°hagy√°s lass√≠tja a flow-t.",
            "Lambda monitoring Git esem√©nyekre t√∫l komplex.",
            "Fejleszt≈ëk k√©zzel tag-el√©se hibalehet≈ës√©get rejt."
        ]
        },
        "examTip": "‚ÄûAutomatikus verzi√≥-tag‚Äù ‚Üí buildspec k√∂rnyezeti v√°ltoz√≥",
        "difficulty": "Medium"
    },
    {
        "id": 56,
        "question": "In a multi-account structure using AWS CodePipeline managed via AWS CloudFormation StackSets, how should you implement a new pipeline change (e.g., additional manual approval step) across all accounts while minimizing operational overhead?",
        "options": [
        "Update each pipeline individually in every account.",
        "Use CloudFormation StackSets from management account with a template update and automatic account propagation.",
        "Use a GitHub Actions workflow to update pipelines via AWS CLI per account.",
        "Create a custom script to assume roles in each account and apply updates."
        ],
        "correctIndex": 1,
        "explanation": {
        "hu": "StackSets lehet≈ëv√© teszi a sablonfriss√≠t√©st egyszerre t√∂bb sz√°ml√°ra. Ez minim√°lis operat√≠v overhead-et √©s k√∂vetkezetess√©get biztos√≠t.",
        "whyCorrect": "Centraliz√°lt update using StackSets = sk√°l√°zhat√≥ √©s automatiz√°lt.",
        "whyWrong": [
            "Egyes√©vel t√∂rt√©n≈ë update magas overhead.",
            "GitHub Actions per-account script same overhead as manual.",
            "Custom script fenntart√°sa √©s jogosults√°g kezel√©se bonyolult."
        ]
        },
        "examTip": "‚ÄûMulti-account pipeline update‚Äù ‚Üí CloudFormation StackSets",
        "difficulty": "Hard"
    },
    {
        "id": 57,
        "question": "Your pipeline uses a custom Docker image for build in CodeBuild. The security team requires that every build runs in a fresh container with no persistent build state and uses the latest patched base image. How should you enforce this requirement with minimal maintenance?",
        "options": [
        "Hardcode the image version in the buildspec and update manually monthly.",
        "Use CodeBuild imagePuller to pull the latest base image at build time.",
        "Use a CodePipeline change detection trigger for the image repository and update the build project when a new base image version is pushed.",
        "Use CodeBuild managed image with auto-update enabled and schedule a monthly review."
        ],
        "correctIndex": 2,
        "explanation": {
        "hu": "Image change detection ‚Üí trigger build-projekt friss√≠t√©se automatikusan, minimaliz√°lva k√©zi l√©p√©st √©s biztos√≠tva legfrissebb image.",
        "whyCorrect": "Automatiz√°lt trigger a leg√∫jabb k√©pverzi√≥ra reag√°l, megfelel a security k√∂vetelm√©nynek.",
        "whyWrong": [
            "Hardcode manu√°lis update-et k√∂vet.",
            "imagePuller nem l√©tezik CodeBuild-ben.",
            "Managed image auto-update nem garant√°lja a testelt bazis-image-t."
        ]
        },
        "examTip": "‚ÄûCI haszn√°lja mindig latest patched base image‚Äù ‚Üí trigger alapj√°n pipeline update",
        "difficulty": "Hard"
    },
    {
        "id": 58,
        "question": "During the testing phase of the SDLC pipeline, the team wants to automatically generate a release report that includes build results, test coverage, and vulnerability scan results. What is the BEST approach to implement this?",
        "options": [
        "Use CodeBuild to output all test results to CloudWatch Logs and use a scheduled Lambda to parse logs and generate PDF report in S3.",
        "Configure CodeBuild to publish results to AWS CodeBuild Test Reports and use Amazon QuickSight on the generated data in S3 for dashboard/report.",
        "Have developers manually export reports from their IDE and upload to S3.",
        "Use CloudWatch Metrics for each result and visualize them in CloudWatch dashboard only."
        ],
        "correctIndex": 1,
        "explanation": {
        "hu": "CodeBuild Test Reports + data-lake S3 + QuickSight = automatikus, sk√°l√°zhat√≥ √©s vizualiz√°lhat√≥ jelent√©sk√©sz√≠t√©st biztos√≠t.",
        "whyCorrect": "Integr√°lt megold√°s CI/Test/Reporting folyamatra, kev√©s k√©zi l√©p√©st ig√©nyel.",
        "whyWrong": [
            "Lambda parsing manual munk√°t jelent.",
            "Fejleszt≈ëi k√©zi export hibalehet≈ës√©get jelent.",
            "CloudWatch dashboard nem kiterjedt jelent√©s-gener√°l√°sra."
        ]
        },
        "examTip": "‚ÄûAutomatikus release riport‚Äù ‚Üí CodeBuild Test Reports + S3 + QuickSight",
        "difficulty": "Medium"
    },
    {
        "id": 59,
        "question": "A development team demands that all artifacts stored in S3 for deployment must be immutable once versioned. They also require a CI pipeline that ensures rollback is possible to any version. What architecture supports both requirements BEST?",
        "options": [
        "Enable versioning on S3 bucket, disable overwrite, use CodePipeline with manual approval and CloudFormation change sets for rollback.",
        "Use DynamoDB to track versions, store artifacts unversioned in S3, and use Lambda to enforce immutability.",
        "Use S3 bucket with versioning and lifecycle policy to delete old versions, CodePipeline uses latest version always.",
        "Use ECR for artifacts instead of S3, trust image tags only and rely on immutable tagging."
        ],
        "correctIndex": 0,
        "explanation": {
        "hu": "S3 versioning + disable overwrite + pipeline prom√≥ci√≥ biztos√≠tja mind az immutabilit√°st, mind a vissza√°ll√≠t√°si lehet≈ës√©get.",
        "whyCorrect": "Native S3 versioning + immutability + pipeline rollback integr√°ci√≥ megfelel≈ë gyakorlat.",
        "whyWrong": [
            "DynamoDB script-megold√°s t√∫l komplex.",
            "Lifecycle policy t√∂rli verzi√≥kat ‚Üí nem garant√°l rollback.",
            "ECR nem √°ltal√°nos artifact t√°rol√≥ minden t√≠pusra."
        ]
        },
        "examTip": "‚ÄûImmutable artifact + rollback‚Äù ‚Üí S3 versioning + pipeline",
        "difficulty": "Hard"
    },
    {
        "id": 60,
        "question": "Your SDLC pipeline runs thousands of builds per day across many microservices. The team wants to reduce overall build time without compromising test coverage or artifact quality. What strategy should be applied?",
        "options": [
        "Increase CodeBuild compute size and let all tests run in one monolithic project.",
        "Use CodeBuild batch mode to execute multiple microservice builds in parallel, share cache layers for dependencies, and publish metrics to CodeBuild build reports.",
        "Reduce test coverage to speed up builds.",
        "Use separate pipelines for each microservice with no shared logic."
        ],
        "correctIndex": 1,
        "explanation": {
        "hu": "Batch mode + shared cache layers + parallel builds minimaliz√°lja az id≈ët, fenntartva a min≈ës√©get.",
        "whyCorrect": "AWS CodeBuild batch builds t√°mogatja p√°rhuzamos √©p√≠t√©st, cache-el√©s cs√∂kkenti id≈ët.",
        "whyWrong": [
            "Nagyobb g√©p nem felt√©tlen√ºl hat√©konyabb.",
            "Teszt lefedetts√©g cs√∂kkent√©se kock√°zatos.",
            "Pipelines elk√ºl√∂n√≠t√©se n√∂veli overheadet."
        ]
        },
        "examTip": "‚ÄûT√∂bb build ‚Üí p√°rhuzamos + cache‚Äù ‚Üí CodeBuild batch mode",
        "difficulty": "Hard"
    },
    {
        "id": 61,
        "question": "A large monolithic application is being refactored into microservices. The CI/CD pipeline needs to detect when a service‚Äôs code change impacts another service (shared library). Which strategy provides the BEST automation?",
        "options": [
        "Manually tag and deploy each microservice when a shared library changes",
        "Use a monorepo with dependency graph tooling that triggers builds of impacted microservices automatically",
        "Break each service into separate repos and rebuild all when shared library changes",
        "Ignore shared library changes and deploy services regularly"
        ],
        "correctIndex": 1,
        "explanation": {
        "hu": "Monorepo + dependency graph lehet≈ëv√© teszi, hogy amikor a shared library v√°ltozik, csak az √©rintett mikro-szolg√°ltat√°sok √©p√ºljenek √∫jra. Automatiz√°l √©s cs√∂kkenti a felesleges build-eket.",
        "whyCorrect": "Automatikus dependency graph + trigger = hat√©kony √©s sk√°l√°zhat√≥",
        "whyWrong": [
            "Manu√°lis tagging lass√∫ √©s hib√°s lehet",
            "Minden rebuild feleslegesen id≈ë- √©s er≈ëforr√°s-ig√©nyes",
            "Ignor√°l√°s hib√°hoz vezethet"
        ]
        },
        "examTip": "Monorepo + dependency graph ‚Üí csak √©rintett build",
        "difficulty": "Hard"
    },
    {
        "id": 62,
        "question": "Your CI pipeline runs unit tests and integration tests, but acceptance tests still run manually. You want to automate acceptance tests in a production-like environment but avoid affecting live users. What should you implement?",
        "options": [
        "Run acceptance tests in production with traffic diverted to test instances",
        "Run acceptance tests in staging that mirrors production and then promote artifact",
        "Run acceptance tests after production release and roll back if failure",
        "Skip acceptance tests since integration tests cover them"
        ],
        "correctIndex": 1,
        "explanation": {
        "hu": "Acceptance teszteknek production-like, de izol√°lt k√∂rnyezetben kell futniuk, m√©gis automatiz√°lva legyenek. Staging mirror k√∂rnyezet erre ide√°lis.",
        "whyCorrect": "Staging mirror + automatikus acceptance = minimal risk + automatiz√°l√°s",
        "whyWrong": [
            "Production tesztel√©s vesz√©lyes live felhaszn√°l√≥kn√°l",
            "Teszt ut√°n rollback = t√∫l k√©s≈ën",
            "Kiz√°r√°sa cs√∂kkenti min≈ës√©get"
        ]
        },
        "examTip": "Acceptance tests ‚Üí Production-like but isolated environment",
        "difficulty": "Medium"
    },
    {
        "id": 63,
        "question": "A pipeline push ut√°n t√∂bb technol√≥gia haszn√°lat√°val k√©sz√ºl (Java, Python, Go). To standardize the build, the team wants to use same build infrastructure and avoid multiple CodeBuild projects. Which solution is BEST?",
        "options": [
        "Create one CodeBuild project that uses a container image containing all runtimes and run each language in separate buildphase",
        "Create separate CodeBuild projects for each language",
        "Use EC2 instances with custom scripts instead of CodeBuild",
        "Use one CodeBuild project but detect language and delegate to microservices"
        ],
        "correctIndex": 0,
        "explanation": {
        "hu": "Egy CodeBuild projekt t√∂bb runtime-mal ‚Äì kont√©nerbe integr√°lva ‚Äì, lehet≈ëv√© teszi standardiz√°lt build k√∂rnyezetet, kevesebb projekt-overhead-dal.",
        "whyCorrect": "Single projekt + unified container = konszisztens, kevesebb fenntart√°s",
        "whyWrong": [
            "T√∂bb projekt overhead-dal j√°r",
            "EC2 custom script = t√∂bb operat√≠v terhet",
            "Deleg√°l√°s mikro-szolg√°ltat√°sokra felesleges komplex"
        ]
        },
        "examTip": "Multi-language build ‚Üí one project with unified container",
        "difficulty": "Hard"
    },
    {
        "id": 64,
        "question": "Your build artifacts include proprietary data that must not leave your organization‚Äôs VPC. What is the MOST SECURE way to store and deploy those artifacts in your pipeline?",
        "options": [
        "Store artifacts in an S3 bucket without encryption and restrict IAM",
        "Use an S3 VPC endpoint, KMS CMK with restricted policy, deploy with pipeline inside the same VPC",
        "Push artifacts to a public registry but set access to private",
        "Encrypt artifacts client-side and store in S3 public bucket"
        ],
        "correctIndex": 1,
        "explanation": {
        "hu": "S3 VPC endpoint + customer-managed KMS key + policy restrict = artefaktok soha nem mennek internetre, csak VPC-n bel√ºl maradnak.",
        "whyCorrect": "Legmagasabb biztons√°g, adat nem hagyja el a VPC-t",
        "whyWrong": [
            "Encryption n√©lk√ºl nincs elegend≈ë v√©delem",
            "Publikus registry nem private",
            "Client-side encryption nem elegend≈ë az ir√°ny√≠t√°s szempontj√°b√≥l"
        ]
        },
        "examTip": "Secure artifact storage ‚Üí S3 VPC endpoint + CMK",
        "difficulty": "Hard"
    },
    {
        "id": 65,
        "question": "The team wants to enforce that every change to infrastructure code (Terraform) triggers automated tests, linting, and policy checks before being applied. Which model should be implemented?",
        "options": [
        "Manual review before Terraform apply",
        "Use GitHub pull request flow, GitHub Actions or CodeBuild for linting and policy checks, then merge triggers Terraform apply via CodePipeline",
        "Apply Terraform directly in production and fix issues later",
        "Run Terraform locally then commit state"
        ],
        "correctIndex": 1,
        "explanation": {
        "hu": "Pull request flow + automated linting and policy checks biztos√≠tja a ‚Äúshift-left‚Äù infra-code min≈ës√©get √©s megfelel√©st.",
        "whyCorrect": "Automatiz√°l √©s kor√°n felfedez hib√°kat",
        "whyWrong": [
            "Manu√°lis review lass√∫",
            "K√∂zvetlen apply kock√°zatos",
            "Helyi futtat√°s nincs k√∂zpontilag ellen≈ërizve"
        ]
        },
        "examTip": "Infra code ‚Üí PR + automatikus lint + policy check",
        "difficulty": "Medium"
    },
    {
        "id": 66,
        "question": "A requirement: every build produces an immutable docker image tagged with semantic versioning, the same image must be deployed across all environments. What pipeline architecture ensures immutability and traceability?",
        "options": [
        "Build image in dev, retag and rebuild for prod",
        "Build image once, store tag & digest, promote that exact image across dev ‚Üí staging ‚Üí prod",
        "Build separate image per environment",
        "Use latest tag always and update"
        ],
        "correctIndex": 1,
        "explanation": {
        "hu": "Azonos image egyszer √©p√ºl el ‚Üí digest r√∂gz√≠tve ‚Üí minden k√∂rnyezet ugyanazt haszn√°lja. √çgy biztos√≠tod az ‚ÄòWhat you test is what you deploy‚Äô elvet.",
        "whyCorrect": "Immutability + traceability modell",
        "whyWrong": [
            "Rebuild v√°ltoz√°st okoz",
            "Separate image per environment = variancia",
            "latest tag = nem reproduk√°lhat√≥"
        ]
        },
        "examTip": "Same image across envs ‚Üí build once, digest store",
        "difficulty": "Hard"
    },
    {
        "id": 67,
        "question": "A pipeline currently deploys to a single region. Business now requires multi-region deployment for disaster tolerance, using same pipeline. What is BEST approach?",
        "options": [
        "Duplicate pipeline for each region manually",
        "Use CodePipeline with cross-region actions replicating artifacts and deploying to each region in stages",
        "Use CloudFormation StackSets only",
        "Use manual triggering per region"
        ],
        "correctIndex": 1,
        "explanation": {
        "hu": "CodePipeline cross-region stages lehet≈ëv√© teszik, hogy egy pipeline t√∂bb r√©gi√≥ba deploy-oljon. Egys√©ges flow, kevesebb overhead.",
        "whyCorrect": "Native multi-region support CodePipeline-ban",
        "whyWrong": [
            "Duplik√°lt pipeline = overhead",
            "StackSets nem el√©g deploy-mechanizmus t√∂bb r√©gi√≥ba",
            "Manual trigger = nincs automatiz√°l√°s"
        ]
        },
        "examTip": "Multi-region deployment ‚Üí single pipeline with cross-region actions",
        "difficulty": "Medium"
    },
    {
        "id": 68,
        "question": "The test coverage for your codebase needs to be published to stakeholders automatically after each build, with trend graphs. Which solution is BEST to implement?",
        "options": [
        "Attach test coverage artifact in S3 and send email per build",
        "Use CodeBuild Test Reports feature and export results to Amazon Athena + QuickSight for dashboards",
        "Generate coverage report locally and manually upload",
        "Send data to CloudWatch metrics and use dashboard"
        ],
        "correctIndex": 1,
        "explanation": {
        "hu": "Test Reports + Athena + QuickSight = automatiz√°lt, trendk√∂vet√©sre alkalmas √©s grafikusan megjelen√≠thet≈ë jelent√©s.",
        "whyCorrect": "Sk√°l√°zhat√≥, automatiz√°lt √©s vizualiz√°lhat√≥ megold√°s",
        "whyWrong": [
            "Per-build email nem trendk√∂vethet≈ë",
            "Manu√°lis upload = lass√∫",
            "CloudWatch dashboard nem kifejezetten test coverage-re",
            " "
        ]
        },
        "examTip": "Coverage trend ‚Üí Test Reports + Athena + QuickSight",
        "difficulty": "Hard"
    },
    {
        "id": 69,
        "question": "During a build, secret-scanning must be performed before any credentials are used in the pipeline. What is BEST practice for this requirement?",
        "options": [
        "Add secret-scanning step as first phase in CodeBuild buildspec.yml",
        "Rely on developers to not commit secrets",
        "Use CI linting job only",
        "Scan in production logs afterwards"
        ],
        "correctIndex": 0,
        "explanation": {
        "hu": "Secret-scanning build-f√°zis elej√©n biztos√≠tja, hogy k√≥dba ne ker√ºljenek √©rz√©keny adatok ‚Äî shift-left security modell.",
        "whyCorrect": "Automation + early detection = legjobb gyakorlat",
        "whyWrong": [
            "Fejleszt≈ëk megb√≠zhat√≥s√°g√°ra hagyatkozni kock√°zatos",
            "Csak linting nem el√©g m√©ly",
            "Production log ut√°n detection t√∫l k√©s≈ë"
        ]
        },
        "examTip": "Secret scanning ‚Üí build remains first phase",
        "difficulty": "Medium"
    }
  ],
  "flashcards": [
    {"id": "fc1", "front": "Mi a CodeCommit st√°tusza 2024-t≈ël?", "back": "Deprecated √∫j √ºgyfelek sz√°m√°ra (2024 j√∫lius). Megl√©v≈ë √ºgyfelek haszn√°lhatj√°k tov√°bb, de √∫j fejleszt√©sek nincsenek."},
    {"id": "fc2", "front": "Mi a k√ºl√∂nbs√©g a CodeBuild √©s CodeDeploy k√∂z√∂tt?", "back": "CodeBuild: Build √©s teszt (ford√≠t√°s, csomagol√°s)\nCodeDeploy: Deployment (telep√≠t√©s c√©lk√∂rnyezetbe)"},
    {"id": "fc3", "front": "Hol defini√°lod a build l√©p√©seket CodeBuild-ben?", "back": "buildspec.yml f√°jlban a repository gy√∂ker√©ben"},
    {"id": "fc4", "front": "Melyek a buildspec.yml f≈ë f√°zisai?", "back": "install: Runtime √©s dependency telep√≠t√©s\npre_build: Build el≈ëtti l√©p√©sek\nbuild: T√©nyleges build parancsok\npost_build: Build ut√°ni l√©p√©sek (push, cleanup)"},
    {"id": "fc5", "front": "Mi a CodeArtifact?", "back": "Managed artifact repository service - csomagok t√°rol√°sa √©s megoszt√°sa (npm, Maven, PyPI, NuGet)"},
    {"id": "fc6", "front": "H√°ny external connection lehet egy CodeArtifact repository-ban?", "back": "Maximum 1 external connection per repository"},
    {"id": "fc7", "front": "Mi a Blue/Green deployment?", "back": "K√©t teljes k√∂rnyezet: Blue (jelenlegi) √©s Green (√∫j)\nTraffic √°tv√°lt√°s load balancer szinten\nZero downtime, gyors rollback\nHaszn√°ld ha: zero downtime sz√ºks√©ges"},
    {"id": "fc8", "front": "Mi a Canary deployment?", "back": "√öj verzi√≥ kis % forgalommal indul\nFokozatos traffic n√∂vel√©s ha sikeres\nMonitoring k√∂zben\nHaszn√°ld ha: gradual rollout, risk mitigation"},
    {"id": "fc9", "front": "Mi a Rolling deployment?", "back": "P√©ld√°nyok friss√≠t√©se egyenk√©nt vagy csoportokban\nK√∂lts√©ghat√©kony (nincs dupla infrastrukt√∫ra)\nVan r√∂vid downtime lehets√©ges\nHaszn√°ld ha: k√∂lts√©goptimaliz√°l√°s fontosabb mint zero downtime"},
    {"id": "fc10", "front": "Milyen deployment strategy-ket t√°mogat a Lambda?", "back": "AllAtOnce: Azonnali √°tv√°lt√°s\nCanary: K√©t l√©p√©sben (pl. Canary10Percent5Minutes)\nLinear: Egyenletes n√∂vekm√©nyek (pl. Linear10PercentEvery10Minutes)"},
    {"id": "fc11", "front": "Mi a k√ºl√∂nbs√©g a Canary √©s Linear deployment k√∂z√∂tt?", "back": "Canary: 2 l√©p√©s (pl. 10% ‚Üí 100%)\nLinear: T√∂bb egyenl≈ë l√©p√©s (pl. 10% ‚Üí 20% ‚Üí 30% ... ‚Üí 100%)"},
    {"id": "fc12", "front": "Melyek a CodePipeline f≈ë komponensei?", "back": "Stages: Logikai egys√©gek\nActions: Feladatok a stage-ken bel√ºl\nTransitions: √Åtmenet stage-ek k√∂z√∂tt\nArtifacts: Kimenet ‚Üí Bemenet (S3-ban t√°rolva)"},
    {"id": "fc13", "front": "Mi a maximum artifact size CodePipeline-ban?", "back": "5GB per artifact"},
    {"id": "fc14", "front": "Hogyan oszd meg az artifact-okat stage-ek k√∂z√∂tt?", "back": "Output artifacts ‚Üí Input artifacts, S3 bucket-ben t√°rolva KMS titkos√≠t√°ssal"},
    {"id": "fc15", "front": "Hol t√°rolja a CodePipeline az artifact-okat?", "back": "S3 bucket-ben, KMS encryption-nel (cross-account eset√©n customer-managed KMS key sz√ºks√©ges)"},
    {"id": "fc16", "front": "Hogyan m≈±k√∂dik a cross-account CodePipeline?", "back": "1. Pipeline account-ban CodePipeline service role\n2. Target account-ban cross-account role\n3. Trust relationship: Pipeline account ‚Üí Target account\n4. KMS key policy: cross-account hozz√°f√©r√©s"},
    {"id": "fc17", "front": "Mi sz√ºks√©ges cross-account artifact megoszt√°shoz?", "back": "Customer-managed KMS key (nem AWS managed)\nKMS key policy: mindk√©t account hozz√°f√©r√©se\nS3 bucket policy: cross-account PutObject/GetObject"},
    {"id": "fc18", "front": "Mi a confused deputy protection?", "back": "External ID haszn√°lata az AssumeRole-ban, hogy megakad√°lyozzuk a unauthorized cross-account access-t"},
    {"id": "fc19", "front": "Secrets Manager vs Parameter Store - mikor melyiket?", "back": "Secrets Manager: Automatic rotation, RDS integration, $0.40/secret/month\nParameter Store: Nincs auto-rotation, ingyenes (standard tier), hierarchical storage"},
    {"id": "fc20", "front": "Hogyan haszn√°lj secret-eket buildspec.yml-ben?", "back": "env:\n  secrets-manager:\n    DB_PASSWORD: prod/myapp/db:password\n  parameter-store:\n    API_KEY: /prod/myapp/api-key"},
    {"id": "fc21", "front": "Mi a Secrets Manager automatic rotation?", "back": "Lambda function automatikusan friss√≠ti a jelsz√≥t (pl. RDS, Redshift) megadott id≈ëk√∂z√∂nk√©nt (pl. 30 nap)"},
    {"id": "fc22", "front": "Hol futtasd az unit teszteket a pipeline-ban?", "back": "Build stage-ben (CodeBuild), a build parancsok r√©szek√©nt"},
    {"id": "fc23", "front": "Hol futtasd az integration teszteket?", "back": "Post-deployment stage-ben, k√ºl√∂n CodeBuild project"},
    {"id": "fc24", "front": "Milyen t√≠pus√∫ teszteket integr√°ljunk a CI/CD-be?", "back": "Unit tests: Build phase\nIntegration tests: Post-deployment\nSecurity scans: SAST, DAST, dependency check\nAcceptance tests: Production-like environment"},
    {"id": "fc25", "front": "Milyen cache t√≠pusok vannak CodeBuild-ben?", "back": "S3 Cache: Artifact cache S3-ban\nLocal Cache: Docker layer, source, custom cache a build host-on"},
    {"id": "fc26", "front": "Hogyan gyors√≠ts Docker build-et CodeBuild-ben?", "back": "cache:\n  paths:\n    - /var/lib/docker/**/*\n\n√âs haszn√°lj --cache-from flag-et"},
    {"id": "fc27", "front": "Mi a buildspec.yml version leg√∫jabb sz√°ma?", "back": "0.2 (t√°mogatja a runtime version-√∂ket √©s artifact filter-eket)"},
    {"id": "fc28", "front": "Mi az appspec.yml?", "back": "CodeDeploy deployment konfigur√°ci√≥ - deployment hooks, file locations, permissions"},
    {"id": "fc29", "front": "Melyek a CodeDeploy lifecycle hooks sorrendje?", "back": "1. ApplicationStop\n2. BeforeInstall\n3. Install (automatic)\n4. AfterInstall\n5. ApplicationStart\n6. ValidateService"},
    {"id": "fc30", "front": "Mi a CodeDeploy deployment group?", "back": "Target instances vagy Lambda/ECS resources halmaza, ahol a deployment t√∂rt√©nik (tags, ASG, vagy manual selection)"},
    {"id": "fc31", "front": "Mi a deployment configuration CodeDeploy-ban?", "back": "OneAtATime: 1 instance egyszerre\nHalfAtATime: 50% egyszerre\nAllAtOnce: √ñsszes egyszerre"},
    {"id": "fc32", "front": "Hogyan trigger-elj automatic rollback-et CodeDeploy-ban?", "back": "CloudWatch alarm-ot konfigur√°lj, √©s kapcsold a deployment-hez. Ha ALARM state ‚Üí automatic rollback"},
    {"id": "fc33", "front": "Maximum pipeline-ok sz√°ma r√©gi√≥nk√©nt?", "back": "300 (n√∂velhet≈ë support ticket-tel)"},
    {"id": "fc34", "front": "Maximum CodeBuild build timeout?", "back": "60 perc (1 √≥ra)"},
    {"id": "fc35", "front": "Maximum concurrent builds CodeBuild-ben?", "back": "Alap√©rtelmezett: 60, n√∂velhet≈ë support ticket-tel"},
    {"id": "fc36", "front": "Mi a CodeStar Connections?", "back": "AWS service GitHub, GitLab, Bitbucket integr√°ci√≥hoz - OAuth app helyett aj√°nlott (automatic webhook management)"},
    {"id": "fc37", "front": "GitHub App vs OAuth App?", "back": "GitHub App: Aj√°nlott, finomabb permission control\nOAuth App: Legacy, deprecating"},
    {"id": "fc38", "front": "Hogyan trigger-eld a pipeline-t branch filter-rel?", "back": "CodeStar Connection-ban event configuration - csak bizonyos branch-ek trigger-elik (pl. csak main √©s develop)"},
    {"id": "fc39", "front": "Mi a least privilege a CodePipeline IAM role-ban?", "back": "Csak azokat az akci√≥kat enged√©lyezd, amik t√©nylegesen sz√ºks√©gesek minden stage-hez (pl. S3 GetObject/PutObject, CodeBuild StartBuild)"},
    {"id": "fc40", "front": "Hogyan titkos√≠tsd az artifact bucket-et?", "back": "S3 bucket encryption KMS-sel (customer-managed key), KMS key policy cross-account access-hez"},
    {"id": "fc41", "front": "Mi a VPC configuration CodeBuild-ben?", "back": "CodeBuild project-et VPC-be helyezed, hogy hozz√°f√©rjen private resources-hoz (RDS, ElastiCache) security group-okon kereszt√ºl"},
    {"id": "fc42", "front": "CodePipeline stage fails - hol n√©zd meg a logot?", "back": "CloudWatch Logs-ban minden action r√©szletes logot √≠r"},
    {"id": "fc43", "front": "CodeBuild build fail-el - mi a legels≈ë l√©p√©s?", "back": "1. buildspec.yml syntax\n2. IAM role permissions\n3. Environment variables\n4. CloudWatch Logs r√©szletes error message"},
    {"id": "fc44", "front": "CodeDeploy deployment fail - leggyakoribb okok?", "back": "1. CodeDeploy agent nincs telep√≠tve/futva\n2. appspec.yml syntax hiba\n3. IAM instance profile permissions hi√°nya\n4. Health check failure"},
    {"id": "fc45", "front": "Mi a manual approval action CodePipeline-ban?", "back": "Emberi j√≥v√°hagy√°s stage a pipeline-ban (pl. production deployment el≈ëtt) - SNS notification, approval/reject gomb"},
    {"id": "fc46", "front": "Hogyan implement√°lj conditional stage-et?", "back": "Lambda invoke action-nel, ami true/false-t ad vissza, √©s ezen alapszik a k√∂vetkez≈ë stage execution"},
    {"id": "fc47", "front": "Mi a custom action CodePipeline-ban?", "back": "Saj√°t action provider (pl. 3rd party tool integration) - Lambda vagy worker process lehet"},
    {"id": "fc48", "front": "Hogyan ossz meg CodeArtifact package-eket cross-account?", "back": "1. Domain-level resource policy\n2. Target account-ot add hozz√° a policy-hez\n3. Target account: configure repository upstream"},
    {"id": "fc49", "front": "SCENARIO: Zero-downtime deployment for ECS?", "back": "Blue/Green deployment with CodeDeploy + ALB target groups"},
    {"id": "fc50", "front": "SCENARIO: Pipeline fails Access Denied to S3 cross-account?", "back": "Add customer-managed KMS key with cross-account policy, update S3 bucket policy"},
    {"id": "fc51", "front": "SCENARIO: Rollback if error rate > 5%?", "back": "Configure CloudWatch alarm for error rate, enable automatic rollback in CodeDeploy"},
    {"id": "fc52", "front": "SCENARIO: Build takes too long?", "back": "1. Docker layer cache (local)\n2. S3 cache for dependencies\n3. Parallelize steps\n4. Larger compute type"},
    {"id": "fc53", "front": "SCENARIO: Secrets visible in build logs?", "back": "Use Secrets Manager or Parameter Store SecureString, reference in buildspec.yml env.secrets-manager"},
    {"id": "fc54", "front": "SCENARIO: Test new feature with 10% users?", "back": "Canary deployment (Canary10Percent5Minutes) with monitoring and automatic rollback"},
    {"id": "fc55", "front": "EXAM TIP: 'cost-effective' keyword?", "back": "Parameter Store > Secrets Manager, Rolling > Blue/Green"},
    {"id": "fc56", "front": "EXAM TIP: 'zero downtime' keyword?", "back": "Blue/Green deployment"},
    {"id": "fc57", "front": "EXAM TIP: 'gradual rollout with monitoring'?", "back": "Canary deployment with CloudWatch alarms"},
    {"id": "fc58", "front": "EXAM TIP: 'multi-account deployment'?", "back": "Customer-managed KMS key, cross-account IAM role, S3 bucket policy"},
    {"id": "fc59", "front": "EXAM TIP: 'automatic secret rotation'?", "back": "Secrets Manager (Parameter Store nem t√°mogatja)"},
    {"id": "fc60", "front": "EXAM TIP: 'build optimization'?", "back": "Caching (S3 or local), Parallel builds, Larger compute type"}
  ]
}